\documentclass[12pt]{article}

\usepackage[sfdefault]{ClearSans}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{color}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{eurosym}
\usepackage{graphicx}
\usepackage{fancybox}
\usepackage{listings}

\pagestyle{plain}
\title{Sémaphore local}
\author{Anthony Araye et Camille Schnell}
\date{21 février 2018}
\begin{document}
\maketitle
\renewcommand{\contentsname}{Sommaire}
\tableofcontents
\newpage
\section{Introduction}
  \begin{itemize}
    \item Création de sémaphores inter processus et hérités par les fils d'un processus.
    \item Utilisation simple :
    \begin{itemize}
      \item juste la fonctionnalité des sem P et V
      \item non rémanents, ils disparaissent quand les processus meurent (contrairement aux IPC)
      \item plus efficace que les IPC
    \end{itemize}
  \end{itemize}
\newpage
\section{Manuel d'utilisation}
  \subsection{Appels système}
      \textbf{int ss_create([int nbr])}  soit nb de ressources en argument, soit rien et égal à 1 par défaut \\
      \paragraph{Description\\}
      Crée un identifiant de sémaphore utilisable par les autres fonctions ss_P, ss_V et éventuellement ss_delete. \\
      \begin{itemize}
        \item L'id des sémaphores est hérité par tous les fils du processus
        \item Le sémaphore est détruit quand tous les processus qui le possèdent sont morts [ ou lorsqu'on fait un ss_delete()]
      \end{itemize}
      \paragraph{Retour\\}
      Renvoie l'id du sem en cas de succès, sinon -1.
      \paragraph{Erreurs\\}
      ENOMEM : quand l'allocation ne s'est pas faite \\
      ETOOMANY : lq'on a atteint le nb limité de sémaphores par processus (cf /usr/include/errno.h un truc comme ça) \\
      EVAL : lq le nbr en argument est invalide (négatif, ou trop grand) (cf /usr/include/errno.h un truc comme ça) \\

      \newpage
      \textbf{int ss_P(int sid)} \\
      \paragraph{Description\\}
      ss_P décrémente le nb de ressources si le nb de ressources disponibles est non nul ; il bloque le processus si le nb de ressources disponibles est nul et l'enfile dans une file d'attente.
      \paragraph{Retour\\}
      Renvoie 0 en cas de succès et -1 en cas d'erreur.
      \paragraph{Erreurs\\}
      ENOMEM : quand l'allocation ne s'est pas faite \\
      EVAL : si le sid ne correspond pas à un sémaphore créé \\

      \newpage
      \textbf{int ss_V(int sid)} \\
      \paragraph{Description\\}
      ss_V incrémente le nb de ressources, réveille et retire le 1er processus dans la file d'attente s'il existe. ss_V ne peut être appelé que quand au moins une ressource est utilisée ( un ss_V ferme un ss_P ).
      \paragraph{Retour\\}
      Renvoie 0 en cas de succès et -1 en cas d'erreur.
      \paragraph{Erreurs\\}
      ENOMEM : quand l'allocation ne s'est pas faite \\
      EVAL : si le sid ne correspond pas à un sémaphore créé \\

      \newpage
      \textbf{int ss_delete(int sid)} \\
      \paragraph{Description\\}
      Supprime le sem pour le processus sid \\

      \newpage
      \textbf{int ss_dbg(int sid, int* v, int* pids,[ int pidSize ], int compteurDeReference)} avec sid le sem, v le nb de ressources, pids les processus dans la file d'attente, pidSize la taille du tableau pids, compteurDeReference ??
      \paragraph{Description\\}
      ss_dbg va renvoyer le nb de processus dans la file d'attente (avec max pidSize, sinon 10 par défaut)
      \paragraph{Erreurs\\}
      EFAULT : sid et pid valides \\
      ... \\

      \newpage
      \subsection{Exemple}
      \begin{lstlisting}
      int main(int argc, char* argv) {
        int S1, S2;
        if(S1 = ss_create() == -1) {
          blabla
        }
        if(S2 = ss_create() == -1) {
          blabla
        }
        ss_P(S1); ss_P(S2); // prochains ss_P vont être bloqués, tester si = -1

        if(fork() == 0) {
          // fils 1
          ss_P(S1);
          write(1,"fils 1",7);
          ss_V(S1);
          exit(0);
        }
        if(fork() == 0) {
          // fils 2
          ss_P(S2);
          write(1,"fils 2",7);
          ss_V(S2);
          exit(0);
        }
        // pere
        if(argc >= 1) {
          ss_V(S2);
          wait(&status); // on attend la fin du fils 2
          ss_V(S1); // on réveille le fils 1
          wait(&status);
          // on peut refaire 2 ss_P pour vérifier ici
        }
        else {
          idem mais inversé
        }
        write(1,"\n",1);
        return 0;
      }
      \end{lstlisting}

\newpage
\section{Implémentation}
Dans la struct task : ajouter un champ qui correspond aux sémaphores (ss) du processus. \\
ss_create va ajouter un sémaphore dans ce champ, ss_delete va le supprimer. \\
Dans exit(), delete le champ ss s'il n'est pas nul. \\
Dans do_clone(), recopier au sens large la structure (champ) ss dans le fils.

\newpage
\section{Recette}
\paragraph{Création d'un sémaphore}
\begin{itemize}
  \item ss_create
  \item ss_dbg
  \item ss_P()
  \item ss_dbg : la ressource doit être bloquée
  \item ss_V()
  \item ss_dbg : la ressource doit être libérée
  \item ss_del
  \item ss_dbg : erreur car le sem n'existe plus
\end{itemize}

\paragraph{Exemple avec un fils}
Trouver un scénario, ajouter des ss_dbg dans le fils : \\
On fait
\begin{itemize}
  \item ss_P dans le père
  \item ss_dbg dans le père
  \item wait dans le père pour attendre la mort du fils
  \item ss_dbg dans le fils
  \item ss_P dans le fils : ça doit être bloqué (tout)
\end{itemize}

\paragraph{Exemple avec un fils pas coincé}
Trouver un scénario, ajouter des ss_dbg dans le fils. On peut regarder dans le fils si le père est bien dans ss_dbg quand on a un ss_P dans le père. Le fils visualise la file d'attente, voit le père. Si possible l'enlever de la file d'attente et revérifier.

\paragraph{Gros exemple}
Ecriture d'une variable partagée par plusieurs processus. Par ex 4 processus père/fils, 2 qui incrémentent 1000 fois et 2 qui décrémentent 1000 fois une même variable. A la fin, la variable doit être égale à sa valeur initiale.

\end{document}
